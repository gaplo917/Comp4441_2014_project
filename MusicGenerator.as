package  {		import flash.display.MovieClip;	import org.si.sion.*;	import org.si.sion.utils.SiONPresetVoice;	import flash.sampler.StackFrame;	import flashx.textLayout.formats.Float;	import org.si.sound.patterns.Sequencer;	import org.si.sound.SoundObject;	import flash.display.*;    import flash.events.*;    import flash.text.TextField;    import org.si.sion.events.*;	public class MusicGenerator extends MovieClip {		 // preset voice        public var presetVoice:SiONPresetVoice = new SiONPresetVoice();                // voices, notes and tracks        public var voices:Vector.<SiONVoice> = new Vector.<SiONVoice>(16);				/* added by Gary			notes = pitch value,  1 octave = 12			from 0 - 127		*/        public var notes :Vector.<int> = Vector.<int>([36,48,60,72, 43,48,55,60, 65,67,69,70, 72,74,76,77]);				/* added by Gary			length = time played in second		*/        public var length:Vector.<int> = Vector.<int>([ 1, 1, 1, 1,  1, 1, 1, 1,  4, 4, 4, 4,  4, 4, 4, 4]);                // beat counter        public var beatCounter:int;                // control pad        public var matrixPad:MatrixPad;						static public var soundDriver:SiONDriver = new SiONDriver();		static var voicePresets:SiONPresetVoice = new SiONPresetVoice();		 // _onBeat (SiONTrackEvent.BEAT) is called back in each beat at the sound timing.        private function _onBeat(e:SiONTrackEvent) : void         {            matrixPad.beat(e.eventTriggerID & 15);        }                        // _onTimerInterruption (SiONDriver.setTimerInterruption) is called back in each beat at the buffering timing.        private function _onTimerInterruption() : void        {            var beatIndex:int = beatCounter & 15;            for (var i:int=0; i<16; i++) {                if (matrixPad.sequences[i] & (1<<beatIndex)) soundDriver.noteOn(notes[i], voices[i], length[i]);            }            beatCounter++;        }		public function MusicGenerator() {			 var i:int;                        /* set voices from preset				percus = percussion				0 			*/            var percusVoices:Array = presetVoice["valsound.percus"];			/* By testing for each one			0 = basic bass, 			1 = electronic bass 			2 = strong bass			*/            voices[0] = percusVoices[0];  // bass drum            voices[1] = percusVoices[27]; // snare drum            voices[2] = percusVoices[16]; // close hihat            voices[3] = percusVoices[22]; // open hihat            for (i=4; i<8;  i++) voices[i] = presetVoice["valsound.bass18"];  // bass            for (i=8; i<16; i++) voices[i] = presetVoice["valsound.piano1"]; // e.piano                        // listen            soundDriver.setBeatCallbackInterval(1);            soundDriver.addEventListener(SiONTrackEvent.BEAT, _onBeat);            soundDriver.setTimerInterruption(1, _onTimerInterruption);                        // control pad            with(addChild(matrixPad = new MatrixPad(stage))) {                x = y = 72;            }            // start streaming            beatCounter = 0;            soundDriver.play();					}			}	}import flash.display.*;import flash.events.*;import flash.geom.*;class MatrixPad extends Bitmap {    public var sequences:Vector.<int> = new Vector.<int>(16);    private var canvas:Shape = new Shape();    private var buffer:BitmapData = new BitmapData(320, 320, true, 0);    private var padOn:BitmapData  = _pad(0x303050, 0xeeeeee);    private var padOff:BitmapData = _pad(0xeeeeee, 0x000000);    private var pt:Point = new Point();    private var colt:ColorTransform = new ColorTransform(1,1,1,0.1)            function MatrixPad(stage:Stage) {        super(new BitmapData(320, 320, false, 0));        var i:int;        for (i=0; i<256; i++) {            pt.x = (i&15)*20;            pt.y = (i&240)*1.25;            buffer.copyPixels(padOff, padOff.rect, pt);            bitmapData.copyPixels(padOff, padOff.rect, pt);        }        for (i=0; i<16; i++) sequences[i] = 0;        addEventListener("enterFrame", _onEnterFrame);        stage.addEventListener("click",  _onClick);    }            private function _pad(border:int, face:int) : BitmapData {        var pix:BitmapData = new BitmapData(20, 20, false, 0);        canvas.graphics.clear();        canvas.graphics.lineStyle(1, border);        canvas.graphics.beginFill(face);        canvas.graphics.drawRect(1, 1, 17, 17);        canvas.graphics.endFill();        pix.draw(canvas);        return pix;    }            private function _onEnterFrame(e:Event) : void {        bitmapData.draw(buffer, null, colt);    }            private function _onClick(e:Event) : void {        if (mouseX>=0 && mouseX<320 && mouseY>=0 && mouseY<320) {            var track:int = 15-int(mouseY*0.05), beat:int = int(mouseX*0.05);            sequences[track] ^= 1<<beat;            pt.x = beat*20;            pt.y = (15-track)*20;            if (sequences[track] & (1<<beat)) buffer.copyPixels(padOn, padOn.rect, pt);            else buffer.copyPixels(padOff, padOff.rect, pt);        }    }            public function beat(beat16th:int) : void {        for (pt.x=beat16th*20, pt.y=0; pt.y<320; pt.y+=20) bitmapData.copyPixels(padOn, padOn.rect, pt);    }}